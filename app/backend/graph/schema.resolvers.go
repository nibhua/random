package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"strings"
	"vault/graph/model"
	"vault/internal/auth"
	"vault/internal/db"
	filesvc "vault/internal/files"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
)

// UploadFiles is the resolver for the uploadFiles field.
func (r *mutationResolver) UploadFiles(ctx context.Context, files []*graphql.Upload) (*model.UploadResult, error) {
	session, ok := auth.SessionFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	ownerID, err := uuid.Parse(session.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid session user: %w", err)
	}

	owner, err := r.DB.GetUserByID(ctx, ownerID)
	if err != nil {
		log.Printf("upload failed: %v", err)
		return nil, err
	}

	inputs := make([]filesvc.UploadInput, 0, len(files))
	for _, upload := range files {
		if upload == nil || upload.File == nil {
			continue
		}
		inputs = append(inputs, filesvc.UploadInput{
			Filename:     upload.Filename,
			DeclaredMIME: upload.ContentType,
			Reader:       upload.File,
			Size:         upload.Size,
		})
		if closer, ok := upload.File.(io.Closer); ok {
			defer closer.Close()
		}
	}

	if len(inputs) == 0 {
		return &model.UploadResult{Files: []*model.File{}}, nil
	}

	results, err := r.FileSvc.Upload(ctx, owner, inputs)
	if err != nil {
		log.Printf("upload failed: %v", err)
		return nil, err
	}

	ownerModel := mapUser(owner)
	out := make([]*model.File, 0, len(results))
	for _, res := range results {
		deduped := !res.IsNew && res.Blob.RefCount > 1
		out = append(out, mapFile(res.File, res.Blob, ownerModel, deduped))
	}

	return &model.UploadResult{Files: out}, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, id string) (*model.DeletePayload, error) {
	session, ok := auth.SessionFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	ownerID, err := uuid.Parse(session.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid session user: %w", err)
	}

	fileID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file id")
	}

	deleted, err := r.FileSvc.DeleteFile(ctx, fileID, ownerID)
	if err != nil {
		if errors.Is(err, filesvc.ErrNotFound) {
			return &model.DeletePayload{Ok: false}, nil
		}
		log.Printf("delete failed: %v", err)
		return nil, err
	}
	if deleted == nil {
		return &model.DeletePayload{Ok: false}, nil
	}

	return &model.DeletePayload{Ok: true}, nil
}

// CreateShare is the resolver for the createShare field.
func (r *mutationResolver) CreateShare(ctx context.Context, input model.ShareInput) (*model.Share, error) {
	session, ok := auth.SessionFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	ownerID, err := uuid.Parse(session.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid session user: %w", err)
	}

	fileID, err := uuid.Parse(input.FileID)
	if err != nil {
		return nil, fmt.Errorf("invalid file id")
	}

	fileWithBlob, err := r.DB.GetFileWithBlob(ctx, fileID, ownerID)
	if err != nil {
		return nil, err
	}
	if fileWithBlob == nil {
		return nil, errors.New("file not found")
	}

	// Always ensure a token exists and is stable across visibility changes
	var token *string
	if existing, _ := r.DB.GetShareByFileID(ctx, fileID); existing != nil && existing.Token != nil && *existing.Token != "" {
		token = existing.Token
	}
	if token == nil {
		generated := uuid.NewString()
		token = &generated
	}

	shareRec, err := r.FileSvc.ShareFile(ctx, fileID, string(input.Visibility), token, toTimePtr(input.ExpiresAt))
	if err != nil {
		return nil, err
	}

	owner, err := r.DB.GetUserByID(ctx, ownerID)
	if err != nil {
		return nil, err
	}

	deduped := fileWithBlob.Blob.RefCount > 1
	fileModel := mapFile(fileWithBlob.File, fileWithBlob.Blob, mapUser(owner), deduped)

	return mapShare(*shareRec, fileModel), nil
}

// RevokeShare is the resolver for the revokeShare field.
func (r *mutationResolver) RevokeShare(ctx context.Context, id string) (*model.DeletePayload, error) {
	session, ok := auth.SessionFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	ownerID, err := uuid.Parse(session.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid session user: %w", err)
	}

	fileID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file id")
	}

	fileWithBlob, err := r.DB.GetFileWithBlob(ctx, fileID, ownerID)
	if err != nil || fileWithBlob == nil {
		return &model.DeletePayload{Ok: false}, nil
	}

	if err := r.FileSvc.RevokeShare(ctx, fileID); err != nil {
		return nil, err
	}

	return &model.DeletePayload{Ok: true}, nil
}

// Viewer is the resolver for the viewer field.
func (r *queryResolver) Viewer(ctx context.Context) (*model.User, error) {
	session, ok := auth.SessionFromContext(ctx)
	if !ok {
		return nil, nil
	}

	ownerID, err := uuid.Parse(session.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid session user: %w", err)
	}

	user, err := r.DB.GetUserByID(ctx, ownerID)
	if err != nil {
		return nil, err
	}

	return mapUser(user), nil
}

// Files is the resolver for the files field.
func (r *queryResolver) Files(ctx context.Context, scope *model.FileScope, filter *model.FileFilter) (*model.FileConnection, error) {
	session, ok := auth.SessionFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	ownerID, err := uuid.Parse(session.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid session user: %w", err)
	}

	var dbFilter *db.FileFilter
	if filter != nil {
		dbFilter = &db.FileFilter{}
		if filter.Search != nil {
			dbFilter.Search = filter.Search
		}
		if len(filter.MimeTypes) > 0 {
			dbFilter.MimeTypes = filter.MimeTypes
		}
		if filter.MinSize != nil {
			min := int64(*filter.MinSize)
			dbFilter.MinSize = &min
		}
		if filter.MaxSize != nil {
			max := int64(*filter.MaxSize)
			dbFilter.MaxSize = &max
		}
		if len(filter.Tags) > 0 {
			dbFilter.Tags = filter.Tags
		}
		if filter.UploaderName != nil {
			name := strings.TrimSpace(*filter.UploaderName)
			if name != "" {
				dbFilter.UploaderName = &name
			}
		}
		if filter.UploaderID != nil {
			if uid, err := uuid.Parse(*filter.UploaderID); err == nil {
				dbFilter.UploaderID = &uid
			}
		}
		if filter.UploadedFrom != nil {
			from := *filter.UploadedFrom
			dbFilter.UploadedFrom = &from
		}
		if filter.UploadedTo != nil {
			to := *filter.UploadedTo
			dbFilter.UploadedTo = &to
		}
	}

	// Default to OWN if not provided
	effScope := model.FileScopeOwn
	if scope != nil {
		effScope = *scope
	}

	switch effScope {
	case model.FileScopePublic:
		entries, total, err := r.FileSvc.ListPublicFiles(ctx, dbFilter)
		if err != nil {
			log.Printf("public files query failed: %v", err)
			return nil, err
		}
		nodes := make([]*model.File, 0, len(entries))
		for _, entry := range entries {
			uploader, err := r.DB.GetUserByID(ctx, entry.File.OwnerID)
			if err != nil {
				return nil, err
			}
			ownerModel := mapUser(uploader)
			deduped := entry.Blob.RefCount > 1
			nodes = append(nodes, mapFile(entry.File, entry.Blob, ownerModel, deduped))
		}
		return &model.FileConnection{Nodes: nodes, TotalCount: total}, nil
	default: // OWN
		// Ignore uploader filters in OWN scope
		if dbFilter != nil {
			dbFilter.UploaderID = nil
			dbFilter.UploaderName = nil
		}
		entries, total, err := r.FileSvc.ListFiles(ctx, ownerID, dbFilter)
		if err != nil {
			log.Printf("files query failed: %v", err)
			return nil, err
		}
		owner, err := r.DB.GetUserByID(ctx, ownerID)
		if err != nil {
			return nil, err
		}
		ownerModel := mapUser(owner)
		nodes := make([]*model.File, 0, len(entries))
		for _, entry := range entries {
			deduped := entry.Blob.RefCount > 1
			nodes = append(nodes, mapFile(entry.File, entry.Blob, ownerModel, deduped))
		}
		return &model.FileConnection{Nodes: nodes, TotalCount: total}, nil
	}
}

// StorageStats is the resolver for the storageStats field.
func (r *queryResolver) StorageStats(ctx context.Context) (*model.StorageStats, error) {
	session, ok := auth.SessionFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	ownerID, err := uuid.Parse(session.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid session user: %w", err)
	}

	original, deduped, err := r.FileSvc.StorageStats(ctx, ownerID)
	if err != nil {
		log.Printf("storage stats failed: %v", err)
		return nil, err
	}

	savings := original - deduped
	percent := 0.0
	if original > 0 {
		percent = float64(savings) / float64(original) * 100
	}

	return &model.StorageStats{
		TotalUsageBytes:    int(deduped),
		OriginalUsageBytes: int(original),
		SavingsBytes:       int(savings),
		SavingsPercent:     percent,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
